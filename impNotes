What is an Exception?

An exception is an unwanted or unexpected event, which occurs during the execution of a program
 i.e at run time, that disrupts the normal flow of the program’s instructions.

Error vs Exception

Error: An Error indicates a serious problem that a reasonable application should not try to catch.
Exception: Exception indicates conditions that a reasonable application might try to catch.

Exception Hierarchy

All exception and error types are sub classes of class Throwable, which is the base class of the hierarchy.
One branch is headed by Exception. This class is used for exceptional conditions that user programs should catch.
NullPointerException is an example of such an exception. Another branch, Error are used by the Java run-time system(JVM)
to indicate errors having to do with the run-time environment itself(JRE). StackOverflowError is an example of such an error.

How Programmer handles an exception?

Customized Exception Handling: Java exception handling is managed via five keywords: try, catch, throw, throws, and finally.
Briefly, here is how they work. Program statements that you think can raise exceptions are contained within a try block.
If an exception occurs within the try block, it is thrown. Your code can catch this exception (using catch block) and
handle it in some rational manner. System-generated exceptions are automatically thrown by the Java run-time system.
To manually throw an exception, use the keyword throw. Any exception that is thrown out of a method must be specified
as such by a throws clause. Any code that absolutely must be executed after a try block completes is put in a finally block.

Consider the following java program.

 class Scaler{
      public static void main (String[] args) {
                    // array of size 4
                    int[] arr = new int[4];

                 // this statement causes an exception
                  int i = arr[10];

                // the following statement will never execute
                System.out.println("Hello World");
           }
 }
Output :

 Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10 at Scaler.main(Scaler.java:9)

Explanation: In the above example an array is defined with size i.e. you can access elements only from index 0 to 3.
But you trying to access the elements at index 10(by mistake) that’s why it is throwing an exception. In this case,
JVM terminates the program abnormally. The statement System.out.println(“Hello World”); will never execute.
To execute it, we must handle the exception using try-catch. Hence to continue the normal flow of the program,
we need a try-catch clause.

//java Try & Catch block

Java try block:


Java try block is used to enclose the code that might throw an exception. It must be used within the method.

If an exception occurs at the particular statement of try block, the rest of the block code will not execute.
So, it is recommended not to keeping the code in try block that will not throw an exception.

Java try block must be followed by either catch or finally block.



Java catch block:


Java catch block is used to handle the Exception by declaring the type of exception within the parameter.
The declared exception must be the parent class exception ( i.e., Exception) or the generated exception type.
However, a good approach is to declare the generated type of exception.

The catch block must be used after the try block only. You can use multiple catch block with a single try block.

How to use a try-catch clause

 try {
 // block of code to monitor for errors
 // the code you think can raise an exception
 }
 catch (ExceptionType1 exOb) {
 // exception handler for ExceptionType1
 }
 catch (ExceptionType2 exOb) {
 // exception handler for ExceptionType2
 }



Points to remember :

In a method, there can be more than one statement that might throw an exception, So put all these statements
within its own try block and provide a separate exception handler within own catch block for each of them.
If an exception occurs within the try block, that exception is handled by the exception handler associated with it.
To associate an exception handler, we must put catch block after it. There can be more than one exception handler.
each catch block is an exception handler that handles the exception of the type indicated by its argument.
The argument, ExceptionType declares the type of the exception that it can handle and must be the name of the
class that inherits from Throwable class.
For each try block there can be zero or more catch blocks, but only one finally block.


---------------------------
Deque
The Deque interface of the Java collections framework provides the functionality of a double-ended queue.
It extends the Queue interface.

Classes that Implement Deque:

In order to use the functionalities of the Deque interface, we need to use classes that implement it:

ArrayDeque
LinkedList
In a regular queue, elements are added from the rear and removed from the front. However, in a deque,
we can insert and remove elements from both front and rear.

In Java, we must import the java.util.Deque package to use Deque.

Syntax:

Deque<String> names= new ArrayDeque<>();

Tha above statement creates a Deque of Strings, we can now push and remove Strings from this deque easily.

Methods of Deque:

addFirst() - Adds the specified element at the beginning of the deque. Throws an exception if the deque is full.
addLast() - Adds the specified element at the end of the deque. Throws an exception if the deque is full.
offerFirst() - Adds the specified element at the beginning of the deque. Returns false if the deque is full.
offerLast() - Adds the specified element at the end of the deque. Returns false if the deque is full.
getFirst() - Returns the first element of the deque. Throws an exception if the deque is empty.
getLast() - Returns the last element of the deque. Throws an exception if the deque is empty.
peekFirst() - Returns the first element of the deque. Returns null if the deque is empty.
peekLast() - Returns the last element of the deque. Returns null if the deque is empty.
removeFirst() - Returns and removes the first element of the deque. Throws an exception if the deque is empty.
removeLast() - Returns and removes the last element of the deque. Throws an exception if the deque is empty.
pollFirst() - Returns and removes the first element of the deque. Returns null if the deque is empty.
pollLast() - Returns and removes the last element of the deque. Returns null if the deque is empty.
size() - Return an integer denoting the total number of elements in the deque at present.


-------------------------

Priority Queue

The PriorityQueue class provides the functionality of the heap data structure. It implements the Queue interface.

Unlike normal queues, priority queue elements are retrieved in sorted order.

Suppose, we want to retrieve elements in ascending order. In this case, the head of the priority queue will be the smallest element.
 Once this element is retrieved, the next smallest element will be the head of the queue.

It is important to note that the elements of a priority queue may not be sorted. However, elements are always retrieved in sorted order.


In order to create a priority queue, we must import the java.util.PriorityQueue package. Once we import the package,
here is how we can create a priority queue in Java.

PriorityQueue<Integer> numbers = new PriorityQueue<>();

Here, we have created a priority queue without any arguments. In this case, the head of the priority queue is the smallest element
 of the queue. And elements are removed in ascending order from the queue.

However, we can customize the ordering of elements with the help of the Comparator interface.


Methods:

The PriorityQueue class provides the implementation of all the methods present in the Queue interface.

add() :  Inserts the specified element to the queue. If the queue is full, it throws an exception.
Time Complexity: O(logN) where N denotes the number of elements present in the PriorityQueue.
offer() - Inserts the specified element to the queue. If the queue is full, it returns false. Time Complexity: O(logN)
poll() - returns and removes the head of the queue. Time Complexity: O(logN)
peek() - return the head of the queue. Time Complexity: O(1)


------------------------------

BigInteger

1) Declaration:

 int a, b;
 BigInteger A, B;
2) Initialization:

 a = 54;
 b = 23;
 A = BigInteger.valueOf(54);
 B = BigInteger.valueOf(37);
And for Integers available as string you can initialize them as:

 A = new BigInteger(“54”);
 B = new BigInteger(“123456789123456789”);
3) Mathematical operations:

 BigInteger C = A.add(B);
Other similar function are subtract() , multiply(), divide(), remainder()


String n = sc.next();
BigInteger num = new BigInteger(n);
num.isProbablePrime(1) return true , false according to number is prime or not..

-------------------------------

BigDecimal

Syntax:

Declaration

double a, b;
BigDecimal A, B;
Initialization:

a = 5.4;
b = 2.3;
A = BigDecimal.valueOf(5.4);
B = BigDecimal.valueOf(2.3);
If you are given a String representation of a double number then you can initialize in the following manner:

A = new BigDecimal(“5.4”);
B = new BigDecimal(“1238126387123.1234”);
Extraction of value from BigDecimal:

// value should be in limit of double x
double x = A.doubleValue();

// To get string representation of BigDecimal A
String z = A.toString();
Comparison:

if (a < b) {} // For primitive double
if (A.compareTo(B) < 0) {} // For BigDecimal
Actually compareTo returns -1(less than), 0(Equal), 1(greater than) according to values.

For equality we can also use:

if (A.equals(B)) {} // A is equal to B

------------------------

SubString ..






